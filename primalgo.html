#include <iostream>
#include <vector>
#include <climits>
#include <queue>

using namespace std;

#define MAX 100
#define INF INT_MAX

// Graph structure
class Graph {
public:
    int V;  // Number of vertices (areas)
    vector<pair<int, int>> adj[MAX];  // adjacency list: (node, cost)

    Graph(int V) {
        this->V = V;
    }

    // Add an edge (u, v) with a specific cost
    void addEdge(int u, int v, int cost) {
        adj[u].push_back(make_pair(v, cost));
        adj[v].push_back(make_pair(u, cost));  // because the graph is undirected
    }

    // Function to implement Prim's algorithm to find the MST
    void primMST() {
        // To store the minimum cost edge to each node (initialized to INF)
        vector<int> key(V, INF);
        
        // To store parent of each node to construct the MST
        vector<int> parent(V, -1);
        
        // To check whether a node is included in the MST or not
        vector<bool> inMST(V, false);
        
        // Min-Heap to store the node with the minimum key value
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        // Start with the first node (0th node)
        key[0] = 0;
        pq.push(make_pair(0, 0));  // (key value, node)

        // Run the loop until all vertices are included in the MST
        while (!pq.empty()) {
            int u = pq.top().second;  // node with minimum key
            pq.pop();

            // If this node is already included in MST, skip it
            if (inMST[u]) continue;
            
            // Include the current node in MST
            inMST[u] = true;

            // Process all the neighbors of the current node
            for (auto edge : adj[u]) {
                int v = edge.first;   // Neighbor node
                int weight = edge.second;  // Cost to reach this node

                // If the neighbor node is not yet included in MST and 
                // the cost to reach it is smaller than the current key, update it
                if (!inMST[v] && key[v] > weight) {
                    key[v] = weight;
                    parent[v] = u;
                    pq.push(make_pair(key[v], v));
                }
            }
        }

        // Print the MST
        printMST(parent);
    }

    // Function to print the MST (minimum spanning tree)
    void printMST(vector<int>& parent) {
        int totalCost = 0;
        cout << "Edge\tWeight\n";
        for (int i = 1; i < V; i++) {
            cout << parent[i] << " - " << i << "\t" << getWeight(parent[i], i) << endl;
            totalCost += getWeight(parent[i], i);
        }
        cout << "\nTotal Cost of Water Distribution Network: " << totalCost << endl;
    }

    // Helper function to get the weight of an edge between u and v
    int getWeight(int u, int v) {
        for (auto edge : adj[u]) {
            if (edge.first == v) {
                return edge.second;
            }
        }
        return INF;
    }
};

int main() {
    // Number of nodes in the graph (e.g., number of areas in Shyamora)
    int V = 5;  // Example with 5 nodes (change as needed)

    // Create a graph with V vertices
    Graph g(V);

    // Adding edges (u, v, cost)
    g.addEdge(0, 1, 2);
    g.addEdge(0, 3, 6);
    g.addEdge(1, 2, 3);
    g.addEdge(1, 3, 8);
    g.addEdge(2, 3, 5);
    g.addEdge(2, 4, 7);
    g.addEdge(3, 4, 9);

    // Run Prim's algorithm to find the MST (minimum spanning tree)
    g.primMST();

    return 0;
}
